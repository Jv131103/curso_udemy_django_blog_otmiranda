        Criando o model Post, related_name em ForeignKey e outros detalhes

Em models.py de site_setup.py vamios fazer:

        from typing import Iterable

        from django.db import models
        from utils.images import resize_image
        from utils.model_validators import validate_png


        # Create your models here.
        class MenuLink(models.Model):
        class Meta:
                verbose_name = "Menu Link"
                verbose_name_plural = "Menu Links"

        text = models.CharField(max_length=50)
        url_or_path = models.CharField(max_length=2048)
        new_tab = models.BooleanField(default=False)
        site_setup = models.ForeignKey(
                'SiteSetup',  # Como já fizemos a migração no Django, o tal nos permite fazer isso
                on_delete=models.CASCADE,
                blank=True,
                null=True,
                default=None,
                related_name='menu'
        )

        def __str__(self):
                return self.text


        class SiteSetup(models.Model):
        class Meta:
                verbose_name = "Setup"
                verbose_name_plural = "Setup"

        title = models.CharField(max_length=65)
        description = models.CharField(max_length=255)
        show_header = models.BooleanField(default=True)
        show_search = models.BooleanField(default=True)
        show_menu = models.BooleanField(default=True)
        show_description = models.BooleanField(default=True)
        show_pagination = models.BooleanField(default=True)
        show_footer = models.BooleanField(default=True)

        faveicon = models.ImageField(
                upload_to='assets/favicon/%Y/%m/',
                blank=True,
                default="",
                validators=[validate_png]
        )

        def save(self, *args, **kwargs):
                current_favicon_name = str(self.faveicon.name)
                super().save(*args, **kwargs)
                favicon_changed = False
                if self.faveicon:
                favicon_changed = current_favicon_name != self.faveicon.name
                if favicon_changed:
                resize_image(self.faveicon, 32)

        def __str__(self):
                return self.title

Agra em _header.html vamos fazer:

<header class="header section-wrapper">
  <div class="section-content-wide">
    <div class="section-gap">

      <h1 class="blog-title center pb-base">
        <a class="blog-link" href="/"> {{ site_setup.title }} </a>
      </h1>
      
      {% if site_setup.show_description %}
        <p class="blog-description pb-base center">
          {{ site_setup.description }}
        </p>
      {% endif %}

      {% if site_setup.show_search %}
        <div class="search pb-base center">
          <form class="search-form" action="#" method="get">
            <div class="search-content">
              <label class="sr-only" id="search-label" for="search-input">Search</label>
              <input
                class="search-input"
                type="search"
                name="search"
                id="search-input"
                placeholder="Search"
                value="Non risu potius quam oratione eiciendum? Quo pleb "
              >
              <button class="search-btn" type="submit" aria-labelledby="search-label">
                <i class="fa fa-search"></i>
              </button>
            </div>
          </form>
        </div>
      {% endif %}

      {% if site_setup.show_menu %}
        <nav class="menu">
          <ul class="menu-items">
              {% for link in site_setup.menu.all %}
                <li class="menu-item">
                  {% if link.new_tab %}
                    <a target="_blank" class="menu-link" href="{{ link.url_or_path }}">{{ link.text }}</a>
                  {% else %}
                    <a class="menu-link" href="{{ link.url_or_path }}">{{ link.text }}</a>
                  {% endif %}
                </li>
              {% endfor %}
          </ul>
        </nav>
      {% endif %}
      
    </div>
  </div>
</header>

Agra em models.py de blog, vamos fazer:

        from django.contrib.auth.models import User
        from django.db import models
        from utils.rands import new_slugfy


        # Create your models here.
        class Tag(models.Model):
        class Meta:
                verbose_name = "Tag"
                verbose_name_plural = "Tags"

        name = models.CharField(max_length=255)
        slug = models.SlugField(
                unique=True,
                default=None,
                null=True,
                blank=True,
                max_length=255
        )

        def save(self, *args, **kwargs):
                if not self.slug:
                self.slug = new_slugfy(self.name)
                return super().save(*args, **kwargs)

        def __str__(self) -> str:
                return self.name


        class Category(models.Model):
        class Meta:
                verbose_name = "Category"
                verbose_name_plural = "Categories"

        name = models.CharField(max_length=255)
        slug = models.SlugField(
                unique=True,
                default=None,
                null=True,
                blank=True,
                max_length=255
        )

        def save(self, *args, **kwargs):
                if not self.slug:
                self.slug = new_slugfy(self.name)
                return super().save(*args, **kwargs)

        def __str__(self) -> str:
                return self.name


        class Page(models.Model):
        title = models.CharField(max_length=65,)
        slug = models.SlugField(
                unique=True,
                default=None,
                null=True,
                blank=True,
                max_length=255
        )
        is_published = models.BooleanField(
                default=False,
                help_text=(
                'Este campo precisará estar marcado para'
                'a página ser exibida publicamente.'
                )
        )
        content = models.TextField()

        def save(self, *args, **kwargs):
                if not self.slug:
                self.slug = new_slugfy(self.title)
                return super().save(*args, **kwargs)

        def __str__(self) -> str:
                return self.title


        class Post(models.Model):
        class Meta:
                verbose_name = "Post"
                verbose_name_plural = "Posts"

        title = models.CharField(max_length=65,)
        slug = models.SlugField(
                unique=True,
                default=None,
                null=True,
                blank=True,
                max_length=255
        )
        excerpt = models.CharField(max_length=150)
        is_published = models.BooleanField(
                default=False,
                help_text=(
                'Este campo precisará estar marcado para'
                'o post ser exibido publicamente.'
                )
        )
        content = models.TextField()
        cover = models.ImageField(upload_to='posts/%Y/%m/', blank=True, default='')
        cover_in_post_content = models.BooleanField(
                default=True,
                help_text=(
                "Se marcado, exibirá a capa dentro do POST."
                )
        )
        created_at = models.DateTimeField(auto_now_add=True)
        created_by = models.ForeignKey(
                User,
                on_delete=models.SET_NULL,
                blank=True, null=True,
                related_name='post_created_by'
        )
        updated_at = models.DateTimeField(auto_now=True)
        updated_by = models.ForeignKey(
                User,
                on_delete=models.SET_NULL,
                blank=True, null=True,
                related_name='post_updated_by'
        )
        category = models.ForeignKey(
                Category, on_delete=models.SET_NULL, null=True, blank=True,
                default=None,
        )
        tags = models.ManyToManyField(Tag, blank=True, default='')

        def __str__(self) -> str:
                return self.title

        def save(self, *args, **kwargs):
                if not self.slug:
                self.slug = new_slugfy(self.title)
                return super().save(*args, **kwargs)

Por fim em admin.py de blog vamos realizar:

        from blog.models import Category, Page, Post, Tag
        from django.contrib import admin


        # Register your models here.
        @admin.register(Tag)
        class TagAdmin(admin.ModelAdmin):
        list_display = "id", "name", "slug"
        list_display_links = "name",
        search_fields = "id", "name", "slug"
        list_per_page = 10
        ordering = "-id",
        prepopulated_fields = {
                "slug": ("name",),
        }


        @admin.register(Category)
        class CategoryAdmin(admin.ModelAdmin):
        list_display = "id", "name", "slug"
        list_display_links = "name",
        search_fields = "id", "name", "slug"
        list_per_page = 10
        ordering = "-id",
        prepopulated_fields = {
                "slug": ("name",),
        }


        @admin.register(Page)
        class PageAdmin(admin.ModelAdmin):
        list_display = "id", "title", "is_published",
        list_display_links = "title",
        search_fields = "id", "slug", "title", "content"
        list_per_page = 50
        list_filter = "is_published",
        list_editable = "is_published",
        ordering = "-id",
        prepopulated_fields = {
                "slug": ("title",),
        }


        @admin.register(Post)
        class PostAdmin(admin.ModelAdmin):
        list_display = 'id', 'title', 'is_published', 'created_by',
        list_display_links = 'title',
        search_fields = 'id', 'slug', 'title', 'excerpt', 'content',
        list_per_page = 50
        list_filter = 'category', 'is_published',
        list_editable = 'is_published',
        ordering = '-id',
        readonly_fields = 'created_at', 'updated_at', 'created_by', 'updated_by',
        prepopulated_fields = {
                "slug": ('title',),
        }
        autocomplete_fields = 'tags', 'category',

