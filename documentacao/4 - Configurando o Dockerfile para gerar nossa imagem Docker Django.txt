        Configurando o Dockerfile para gerar nossa imagem Docker Django

1. Na raiz do projeto, crie o arquivo chamado de Dockerfile.

    √â nele que vamos configurar o funcionamento do nosso container.

    . Antes de iniciarmos, crie um diret√≥rio chamado de scripts

    . Agora montamos nosso Dockerfile dessa maneira:

        # Aqui colocamos uma imagem python para rodar com Alpine, que √© uma vers√£o leve do Linux
        FROM python3.11.3-alpine3.18

        # Aqui s√≥ define o dono do Container
        LABEL maintainer="Jv131103 - https://github.com/Jv131103"

        # Essa vari√°vel de ambiente √© usada para controlar se o Python deve 
        # gravar arquivos de bytecode (.pyc) no disco. 1 = N√£o, 0 = Sim
        ENV PYTHONDONTWRITEBYTECODE 1

        # Define que a sa√≠da do Python ser√° exibida imediatamente no console ou em 
        # outros dispositivos de sa√≠da, sem ser armazenada em buffer.
        # Em resumo, voc√™ ver√° os outputs do Python em tempo real.
        ENV PYTHONUNBUFFERED 1

        # Copia a pasta "djangoapp" e "scripts" para dentro do container.
        COPY djangoapp /djangoapp
        COPY scripts /scripts

        # Entra na pasta djangoapp no container
        WORKDIR /djangoapp

        # A porta 8000 estar√° dispon√≠vel para conex√µes externas ao container
        # √â a porta que vamos usar para o Django.
        EXPOSE 8000

        # RUN executa comandos em um shell dentro do container para construir a imagem. 
        # O resultado da execu√ß√£o do comando √© armazenado no sistema de arquivos da 
        # imagem como uma nova camada.
        # Agrupar os comandos em um √∫nico RUN pode reduzir a quantidade de camadas da 
        # imagem e torn√°-la mais eficiente.
        RUN python -m venv /venv && \
        /venv/bin/pip install --upgrade pip && \
        /venv/bin/pip install -r /djangoapp/requirements.txt && \
        adduser --disabled-password --no-create-home duser && \
        mkdir -p /data/web/static && \
        mkdir -p /data/web/media && \
        chown -R duser:duser /venv && \
        chown -R duser:duser /data/web/static && \
        chown -R duser:duser /data/web/media && \
        chmod -R 755 /data/web/static && \
        chmod -R 755 /data/web/media && \
        chmod -R +x /scripts

        # Adiciona a pasta scripts e venv/bin 
        # no $PATH do container.
        ENV PATH="/scripts:/venv/bin:$PATH"

        # Muda o usu√°rio para duser
        USER duser

        # Executa o arquivo scripts/commands.sh
        CMD ["commands.sh"]

    . Agora, note que temos um arquivo commands.sh. √â ele que ir√° permitir que executamos
    de forma autom√°tica a atualiza√ß√£o do Django.

        Por√©m, ele n√£o est√° criado em nosso projeto, logo, vamos cri√°-lo em
        scripts/ o arquivo commands.sh e nele faremos o seguinte:

            #!/bin/sh

            # O shell ir√° encerrar a execu√ß√£o do script quando um comando falhar
            set -e

            while ! nc -z $POSTGRES_HOST $POSTGRES_PORT; do
            echo "üü° Waiting for Postgres Database Startup ($POSTGRES_HOST $POSTGRES_PORT) ..." &
            sleep 0.1
            done

            echo "‚úÖ Postgres Database Started Successfully ($POSTGRES_HOST:$POSTGRES_PORT)"

            python manage.py collectstatic
            python manage.py migrate
            python manage.py runserver
